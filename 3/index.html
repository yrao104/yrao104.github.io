<!DOCTYPE html>
<html>
<head>
    <title>CS 180 Project 3</title>
    <style>
        body {
            font-family: Georgia, sans-serif;
            margin: 20px;
            text-align: center;
            background: radial-gradient(circle,rgba(238, 174, 202, 1) 0%, rgba(148, 187, 233, 1) 100%);
        }

        h1 {
            margin-bottom: 30px;
            margin-top: 60px;
        }

        h2 {
            margin-bottom: 20px;
            margin-top: 0px;
        }

        .info {
            margin-left: auto;
            margin-right: auto;
            width: 80%;
            border-radius: 8px;
            text-align: left;
            background: #e6e0f5;
            padding: 50px;
        }

        .container {
            text-align: center;
            max-width: 50%;
        }

        .solo-row .container {
            max-width: 60%;
        }

        .container img {
            height: 300px;
            width: auto;
        }

        hr {
            margin-top: 40px;
            margin-bottom: 40px; 
        }

        .caption {
            font-size: 15px;
            margin-top: 5px;
        }

        .row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        p {
            margin-top: 30px;
            margin-bottom: 30px;
            margin-right: 15px;
            margin-left: 15px;
        }

        .stack-image-container {
            width: 100%;
            text-align: center;
        }

        .stack-image-container img {
            width: 90%;
            height: auto;
            margin-bottom: 5px;
        }

    </style>
</head>
<body>
    <h1>Project #3: (Auto)Stitching Photo Mosaics</h1>

    <h2 style="margin-bottom: 50px">Part A: Image Warping and Mosaicing</h2>

    <div class="info">

        <h2>Part A.1: Shoot the Pictures</h2>

        <p style="text-align: left;">
            In this part, I took 3 sets of images with projective transformations between them.
            I made sure to maintain a fixed center of projection by keeping my body fixed and only rotating my hands to rotate the phone camera.
        </p>

        <div class="row">
            <div class="container">
                <img src="./media/room1.png">
                <div class="caption">Room Image 1</div>
            </div>
            <div class="container">
                <img src="./media/room2.png">
                <div class="caption">Room Image 2</div>
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/couch1.png">
                <div class="caption">Couch Image 1</div>
            </div>
            <div class="container">
                <img src="./media/couch2.png">
                <div class="caption">Couch Image 2</div>
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/scenery1.png">
                <div class="caption">Scenery Image 1</div>
            </div>
            <div class="container">
                <img src="./media/scenery2.png">
                <div class="caption">Scenery Image 2</div>
            </div>
        </div>

        <hr />

        <h2>Part A.2: Recover Homographies</h2>

        <p style="text-align: left;">
            In this part, I calculated the homography matrix by taking in the correspondence points per image. 
        </p>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/computeh.png">
                <div class="caption">Function to compute homography matrix from correspondence points per image.</div>
            </div>
        </div>

        <p style="text-align: left;">
            Here is the system of equations utilized to calculate the homography matrix
        </p>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/eqs.jpeg" style="height: 300px; width: auto">
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/room1c.png">
                <div class="caption">Room Image 1 Correspondence</div>
            </div>
            <div class="container">
                <img src="./media/room2c.png">
                <div class="caption">Room Image 2 Correspondence</div>
            </div>
        </div>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/homoroom.png" style="height: 75px; width: auto;">
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/couch1c.png">
                <div class="caption">Couch Image 1 Correspondence</div>
            </div>
            <div class="container">
                <img src="./media/couch2c.png">
                <div class="caption">Couch Image 2 Correspondence</div>
            </div>
        </div>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/homocouch.png" style="height: 75px; width: auto;">
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/scenery1c.png">
                <div class="caption">Scenery Image 1 Correspondence</div>
            </div>
            <div class="container">
                <img src="./media/scenery2c.png">
                <div class="caption">Scenery Image 2 Correspondence</div>
            </div>
        </div>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/homoscenery.png" style="height: 75px; width: auto;">
            </div>
        </div>

        <hr />

        <h2>Part A.3: Warp the Images</h2>

        <p style="text-align: left;">
            In this part, I wrote functions to warp the images using both nearest neighbor interpolation and bilinear interpolation utilizing inverse warping.
            Then, I applied these warping functions on 2 images for rectification.
            First, I retrieved the bounding box of the image and afterwards I iterated through the ranges of points to apply the inverse homotgraphy matrix on the output points to generate the input points.
            I normalized these input points and then set the warped image indices to the appropriate image points. In addition, I set the alpha channel values to 1 where the image is defined and 0 otherwise.
            For nearest neighbor interpolation, I rounded the input coordinates to the nearest pixel value. For bilinear interpolation, I used a weighted average of the 4 neighboring pixels for the input coordinates.
        </p>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/warpnn.png" style="height: 400px; width: auto">
                <div class="caption">Function to warp image using nearest neighbor interpolation.</div>
            </div>
        </div>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/warpb.png" style="height: 400px; width: auto">
                <div class="caption">Function to warp image using bilinear interpolation.</div>
            </div>
        </div>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/tv.jpg" style="height: 400px; width: auto;">
                <div class="caption">Original TV Image</div>
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/tvnn.jpg" style="height: 400px; width: auto;">
                <div class="caption">Nearest Neighbor Warped TV Image</div>
            </div>
            <div class="container">
                <img src="./media/tvb.jpg" style="height: 400px; width: auto;">
                <div class="caption">Bilinear Warped TV Image</div>
            </div>
        </div>

         <div class="row">
            <div class="stack-image-container">
                <img src="./media/valkyries.jpg" style="height: 500px; width: auto;">
                <div class="caption">Original Valkyries Image</div>
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/valkyriesnn.jpg" style="height: 500px; width: auto;">
                <div class="caption">Nearest Neighbor Warped Valkyries Image</div>
            </div>
            <div class="container">
                <img src="./media/valkyriesb.jpg" style="height: 500px; width: auto;">
                <div class="caption">Bilinear Warped Valkyries Image</div>
            </div>
        </div>

        <p style="text-align: left;">
            <strong>Nearest Neighbor Interpolation vs. Bilinear Interpolation</strong>
            <br>
            The warped images generated using bilinear interpolation are slightly smoother than the warped images generated using nearest neighbor interpolation. 
            Specifically, for the TV images, the border around the TV is smoother in the bilinear interpolated image, especially on the right edge.
            This can similarly be seen on the borders of the valkyries jersey towel. 
            Although the difference is very subtle, it is still there.
        </p>

        <hr />

        <h2>Part A.4: Blend the Images Into a Mosaic</h2>

        <p style="text-align: left;">
            In this part, I blended the original images from A.1 into mosaics. 
            First, I generated the homography matrices for both images. I made the first image the homography matrix recovered in A.2 and the other the identity matrix to warp the first image onto the second.
            Next, I retrieved the bounding boxes for both images using the previous bounding box function I wrote in A.3.
            Afterwards, I created a homography matrix for the final mosaic and multiplied that by the image homography matrices to generate the final image homographies.
            To calculate the alpha channel for each image, I set it to 1 at the center and 0 at the edges of the image, falling off linearly.
            Lastly, I used a weighted average for the final image utilizing these alpha channel values to retrieve the final mosaic.

        </p>

         <div class="row">
            <div class="container">
                <img src="./media/room1.png">
                <div class="caption">Room 1 Image</div>
            </div>
            <div class="container">
                <img src="./media/room2.png">
                <div class="caption">Room 2 Image</div>
            </div>
        </div>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/room_mosaic.png" style="height: 400px; width: auto">
                <div class="caption">Room Mosaic</div>
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/couch1.png">
                <div class="caption">Couch 1 Image</div>
            </div>
            <div class="container">
                <img src="./media/couch2.png">
                <div class="caption">Couch 2 Image</div>
            </div>
        </div>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/couch_mosaic.png" style="height: 400px; width: auto">
                <div class="caption">Couch Mosaic</div>
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/scenery1.png">
                <div class="caption">Scenery 1 Image</div>
            </div>
            <div class="container">
                <img src="./media/scenery2.png">
                <div class="caption">Scenery 2 Image</div>
            </div>
        </div>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/scenery_mosaic.png" style="height: 400px; width: auto">
                <div class="caption">Scenery Mosaic</div>
            </div>
        </div>
  
    </div>



    <h2 style="margin-bottom: 50px; margin-top: 50px">Part B: Feature Matching for Autostitching</h2>

    <div class="info">

        <h2>Part B.1: Harris Corner Detection</h2>

        <p style="text-align: left;">
            In this part, utilized the starter code with the get_harris_corners and dist2 functions to first get the Harris corners and plot them without ANMS.
            Next, I utilized Adaptive Non-Maximal Supression, or ANMS, by getting the Harris corners, calculating the corner strength function, and looping through all corners to calculate the minimum suppression radius.
            I utilized a mask to filter out points that were not robust based on the corner strength function.
            Next, I calculated the suppression radius per point and finally retrieved the top 500 coordinates with the largest suppression radii. 
            Utilizing ANMS ensured that the chosen coordinates were better distributed across the image rather than grouped in certian areas.
        </p>

        <div class="row">
            <div class="container">
                <img src="./media/harris.png">
                <div class="caption">Harris Corners</div>
            </div>
            <div class="container">
                <img src="./media/harris_anms.png">
                <div class="caption">Harris Corners with ANMS</div>
            </div>
        </div>

        <hr />

        <h2>Part B.2: Feature Descriptor Extraction</h2>

        <p style="text-align: left;">
            In this part, I extracted the features of the image.
            First, I retrieved the ANMS corners using the previous part (B.1). 
            Then, I downsampled the image by blurring it using a Gaussian filter.
            After, I looped through all of the ANMS corners and sampled patches from 40x40 windows around the corners.
            I exxtraced axis-aligned 8x8 patches from these windows and used bias/gain normalization for the visualizations to be in the [0, 1] range.
            Lastly, I flattened these normalized patches to convert them to feature descriptor vectors.
            Below are 16 of these feature descriptor vectors.
        </p>

         <div class="row">
            <div class="container">
                <img src="./media/f1.png" style="height: 200px; width: auto;">
            </div>
            <div class="container">
                <img src="./media/f2.png" style="height: 200px; width: auto;">
            </div>
             <div class="container">
                <img src="./media/f3.png" style="height: 200px; width: auto;">
            </div>
            <div class="container">
                <img src="./media/f4.png" style="height: 200px; width: auto;">
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/f5.png" style="height: 200px; width: auto;">
            </div>
            <div class="container">
                <img src="./media/f6.png" style="height: 200px; width: auto;">
            </div>
             <div class="container">
                <img src="./media/f7.png" style="height: 200px; width: auto;">
            </div>
            <div class="container">
                <img src="./media/f8.png" style="height: 200px; width: auto;">
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/f9.png" style="height: 200px; width: auto;">
            </div>
            <div class="container">
                <img src="./media/f10.png" style="height: 200px; width: auto;">
            </div>
             <div class="container">
                <img src="./media/f11.png" style="height: 200px; width: auto;">
            </div>
            <div class="container">
                <img src="./media/f12.png" style="height: 200px; width: auto;">
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/f13.png" style="height: 200px; width: auto;">
            </div>
            <div class="container">
                <img src="./media/f14.png" style="height: 200px; width: auto;">
            </div>
             <div class="container">
                <img src="./media/f15.png" style="height: 200px; width: auto;">
            </div>
            <div class="container">
                <img src="./media/f16.png" style="height: 200px; width: auto;">
            </div>
        </div>

        <hr />

        <h2>Part B.3: Feature Matching</h2>

        <p style="text-align: left;">
            In this part, I matched features across 2 images. 
            First, I retrieved the feature descriptor vectors for both images using the previous part (B.2). 
            Next, I calculated an array of the difference in distances between both feature descriptor vectors by utilizing the provided dist2 function.
            Next, I looped through these distance differences and retrieved the error for the nearest neighbor and error for the second nearest neighbor by sorting these distances for each index.
            Utilizing this, I applied Lowe's technique with a threshold value of 0.5 to identify which matches were best.
            With this technique, I was able to identify the best matching features. Utilizing Lowe's technique, I was able to retrieve 25 matching features as shown below.
        </p>

        <div class="row">
            <div class="stack-image-container">
                <img src="./media/fmatch.png">
                <div class="caption">Matching Features Between Image Pairs</div>
            </div>
        </div>

        <hr />

         <h2>Part B.4: RANSAC for Robust Homography</h2>

         <p style="text-align: left;">
            In this part, I utilized RANSAC to filter out the outlier feature matches present in the previous image (B.3).
            First, I retrieved the feature pairs using the feature matching function I wrote in the previous part (B.3).
            Then I implemented a RANSAC loop with 1000 iterations.
            In each iteration of this loop, I retrieved 4 random feature pairs, computed the homograph utilizing these pairs and found the inliers by calculating the distance between the points in the second image compared to the first image multiplied by the homography. 
            I kept track of the largest set of inliers in this loop and lastly recomputed the least squares H estimate from these inliers.
            Utilizing this final homography H, I generated the mosaics for all three images below.
        </p>

        <div class="row">
            <div class="container">
                <img src="./media/room_mosaic.png">
                <div class="caption">Room Mosaic Manual Stitching - Part A</div>
            </div>
            <div class="container">
                <img src="./media/room_mosaic_ransac.png">
                <div class="caption">Room Mosaic Automatically Stitching - Part B</div>
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/couch_mosaic.png">
                <div class="caption">Couch Mosaic Manual Stitching - Part A</div>
            </div>
            <div class="container">
                <img src="./media/couch_mosaic_ransac.png">
                <div class="caption">Couch Mosaic Automatically Stitching - Part B</div>
            </div>
        </div>

        <div class="row">
            <div class="container">
                <img src="./media/scenery_mosaic.png">
                <div class="caption">Scenery Mosaic Manual Stitching - Part A</div>
            </div>
            <div class="container">
                <img src="./media/scenery_mosaic_ransac.png">
                <div class="caption">Scenery Mosaic Automatically Stitching - Part B</div>
            </div>
        </div>

        <p style="text-align: left;">
            <strong>Comparison Between Manually and Automatically Stitching</strong>
            <br>
            FIX BELOW
            The warped images generated using bilinear interpolation are slightly smoother than the warped images generated using nearest neighbor interpolation. 
            Specifically, for the TV images, the border around the TV is smoother in the bilinear interpolated image, especially on the right edge.
            This can similarly be seen on the borders of the valkyries jersey towel. 
            Although the difference is very subtle, it is still there.
        </p>

        <hr />

        <h2>Conclusion</h2>

         <p style="text-align: left;">
            The most important thing I learned from this project was how intricate the process of image blending and image editing truly is.
            Overall, the process seems so much simpler when utilizing user interfaces to automatically generate these images for you, but the mathematical equations behind these edits are so complex.
            This project has made me appreciate these tools and libraries that efficiently optimize this process so much more, and I am now eager to understand the inner workings of additional imaging techniques. 
        </p>

    </div>
</body>
</html>
